<div align="center">

## Advent of Code
#### My attempt to use languages to write blazingly fast algorithms

[![verilog](https://img.shields.io/badge/systemverilog-283272.svg?style=for-the-badge&logoColor=white&logo=ieee)](/verilog)
[![C](https://img.shields.io/badge/c-00599C.svg?style=for-the-badge&logoColor=white&logo=c)](/c)
[![Rust](https://img.shields.io/badge/Rust-f74c00.svg?style=for-the-badge&logoColor=white&logo=rust)](/rust)
[![Haskell](https://img.shields.io/badge/Haskell-5D4F85.svg?style=for-the-badge&logoColor=white&logo=haskell)](/haskell)
[![Tinygrad](https://img.shields.io/badge/Tinygrad-FFFFFF.svg?style=for-the-badge&logoColor=black&logo=tinygrad)](/tinygrad)

</div>

## ⇁  Welcome
I want to get good at languages and computer science concepts. So I have selected these languages carefully towards this cole.

I can go over the idea behind each:

* SystemVerilog: Learning how a chip executes a program, and ASIC design
* C: Low level.
* Haskell: Functional.
* Rust: Ownership based.
* Tinygrad: Programming 2.0. Look at data in terms of tensors.

Future languages:
* Agda: Dependent Types

This is my fun folder where I try to achieve both those goals.

## ⇁  Repository structure
The project will be structured the following way:
```
├── language
│   ├── 2022
│   │   ├── day1/
│   │   ├── ...
│   │   ├── day25/
│   │   └── README.md <- For benchmark and time complexity info
│   ├── ...
│   ├── README.md <- check status per year
│   └── 2015/
└── README.md

```
